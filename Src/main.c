/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#include <stdint.h>
#include "../Inc/main.h"
#include "../Inc/gpio.h"
#include "../Inc/tasks.h"




uint32_t psp_of_tasks[TOTAL_TASKS] = {TASK1_STACK_START , TASK2_STACK_START , TASK3_STACK_START , TASK4_STACK_START};
uint32_t task_handlers[TOTAL_TASKS] = {(uint32_t)T1_Handler , (uint32_t)T2_Handler , (uint32_t)T3_Handler , (uint32_t)T4_Handler};
TaskControlBlock tasks[TOTAL_TASKS];
uint8_t c_task = 0 ; //1st task



int main(void)
{

  enable_faults();
  
  gpio_init();

  sched_stack_init(SCHEDULER_STACK_START);

  init_tasks_stack();

  systick_T_init(SYSTEM_TICK_RATE_HZ);

  switch_sp_to_psp();

  T1_Handler();
	for(;;);
}



uint32_t get_psp_value(void){
  return tasks[c_task].stack_pointer;
}

void set_psp_value(uint32_t task_psp){
  tasks[c_task].stack_pointer = task_psp;
}

void update_next_task(void){
  c_task++;
  c_task %= TOTAL_TASKS;
}

__attribute__((naked)) void switch_sp_to_psp(void)
{
	// Initialize PSP

	__asm volatile ("PUSH {LR}");
	__asm volatile ("BL get_psp_value");
	__asm volatile ("MSR PSP, R0");
	__asm volatile ("POP {LR}");

	// Point SP to PSP
	__asm volatile ("MOV R0, #0x02");
	__asm volatile ("MSR CONTROL, R0");
	__asm volatile ("BX LR");
}

void systick_T_init(uint32_t tick) {
  uint32_t *SYST_RVR = (uint32_t*) 0xE000E014;
  uint32_t *SYST_CSR = (uint32_t*) 0xE000E010;

  uint32_t reload_value = (HSI_CLOCK_FREQUENCY_HZ / tick) -1 ;

    //clear the Reload register 24 bits  and then load the count 
        *SYST_RVR &= ~(0x00FFFFFF);
        *SYST_RVR |= reload_value;


    //configure the Control register , clock source enable systick exception and enable the counter 
        *SYST_CSR |=  7 << 0 ;
    
}

__attribute__((naked)) void sched_stack_init(uint32_t stack_sched) {
  __asm volatile ("MSR MSP,R0");
  __asm volatile ("BX LR");
}

void enable_faults() {
  uint32_t *SHCSR = (uint32_t*)0xE000ED24;

  *SHCSR |= ( 7 << 16 ) ;  //mem , bus , usage faults

}

void init_tasks_stack(void) {

  for (int task=0 ; task< TOTAL_TASKS ; task++) {
    tasks[task].task_state = RUNNING;
    tasks[task].stack_pointer = psp_of_tasks[task];
    tasks[task].task_function = task_handlers[task];
  }
  uint32_t *PSP;


  //Stack frame : xPSR / PC / LR / General purpose registers R12 -> R0 / Scratch registers R11 -> R4
  for (int task=0 ; task < TOTAL_TASKS ; task++) {
    PSP = (uint32_t*)tasks[task].stack_pointer;

    PSP--;
    *PSP = xPSR; //0x00100000 T (thumb state) bit of PSR register

    PSP--;
    *PSP = tasks[task].task_function; //PC next instruction to execute is the task handler

    PSP--;
    *PSP = 0xFFFFFFFD; //LR

    for (int reg = 0 ; reg < 13 ; reg++) {
      PSP--;
      *PSP = 0;
    }

    tasks[task].stack_pointer = (uint32_t)PSP;
    
  }
}


/************ HAndlers *************************** */
__attribute__((naked)) void SysTick_Handler(void) {
  //toggle_gpio_d12();
  __asm volatile("PUSH {LR}");
  // __asm volatile("BL toggle_gpio_d12");
  //1. Get current running task's PSP value
  __asm volatile("MRS R0,PSP");
  //2. Using that PSP value store SF2 (R4 to R11)
  __asm volatile("STMDB R0!, {R4-R11}");

  

  //1. save the current value of PSP
  __asm volatile ("BL set_psp_value");


  //1. Decide next task to run
  __asm volatile ("BL update_next_task");

  //2.gets its past PSP value
  __asm volatile ("BL get_psp_value");

  //3. Using that PSP value retrieve SF2(R4 to R11)
  __asm volatile ("LDMIA R0!, {R4-R11}");

  //4. update PSP and exit
  __asm volatile("MSR PSP,R0");

  __asm volatile ("POP {LR}");

  __asm volatile ("BX LR");
}

void HardFault_Handler(void) {
  while(1) {

  }
}

void MemManage_Handler(void) {
  while(1) {
    
  }
}

void BusFault_Handler(void) {
  while(1) {
    
  }
}

void UsageFault_Handler(void) {
  while(1) {
    
  }
}

