/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */



#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


#include <stdint.h>
#include "../Inc/main.h"
#include "../Inc/gpio.h"
#include "../Inc/tasks.h"

// void T1_Handler(void);
// void T2_Handler(void);
// void T3_Handler(void);
// void T4_Handler(void);

void systick_T_init(uint32_t);
__attribute__((naked)) void sched_stack_init(uint32_t);
void init_tasks_stack(void);

__attribute__((naked)) void switch_sp_to_psp(void);
uint32_t get_psp_value(void);
void enable_faults(void);
void set_psp_value(uint32_t task_psp);
void update_next_task(void);


uint32_t psp_of_tasks[TASKS] = {T1_S , T2_S , T3_S , T4_S};
uint32_t task_handlers[TASKS] ;
uint8_t c_task = 0 ; //1st task




// void gpio_init(void) {
//     // Step 1: Enable the clock for GPIOD
//     RCC_AHB1ENR |= (1 << 3); // Bit 3 corresponds to GPIOD

//     // Step 2: Set D12, D13, D14, and D15 as output (00: Input, 01: Output)
//     GPIOD_MODER &= ~((0x3 << (12 * 2)) | (0x3 << (13 * 2)) | (0x3 << (14 * 2)) | (0x3 << (15 * 2))); // Clear mode bits for D12, D13, D14, D15
//     GPIOD_MODER |= ((0x1 << (12 * 2)) | (0x1 << (13 * 2)) | (0x1 << (14 * 2)) | (0x1 << (15 * 2)));  // Set mode to output (01)
// }

// void toggle_gpio_d12(void) {
//     GPIOD_ODR ^= GPIO_PIN_D12; // Toggle D12 using XOR
// }

// void toggle_gpio_d13(void) {
//     GPIOD_ODR ^= GPIO_PIN_D13; // Toggle D12 using XOR
// }

// void toggle_gpio_d14(void) {
//     GPIOD_ODR ^= GPIO_PIN_D14; // Toggle D12 using XOR
// }

// void toggle_gpio_d15(void) {
//     GPIOD_ODR ^= GPIO_PIN_D15; // Toggle D12 using XOR
// }


int main(void)
{
    /* Loop forever */
  enable_faults();
  gpio_init();
  sched_stack_init(SCHED_S);

  task_handlers[0] = (uint32_t)T1_Handler;
  task_handlers[1] = (uint32_t)T2_Handler;
  task_handlers[2] = (uint32_t)T3_Handler;
  task_handlers[3] = (uint32_t)T4_Handler;

  init_tasks_stack();

  systick_T_init(TICK_RATE);

  switch_sp_to_psp();

  T1_Handler();
	for(;;);
}



// void T1_Handler(void) {
//   while (1)
//   {
//     /* code */
//     toggle_gpio_d12();
//   }
  
// }

// void T2_Handler(void) {
//   while (1)
//   {
//     /* code */
//     toggle_gpio_d13();
//   }
  
// }

// void T3_Handler(void) {
//   while (1)
//   {
//     /* code */
//     toggle_gpio_d14();
//   }
  
// }

// void T4_Handler(void) {
//   while (1)
//   {
//     /* code */
//     toggle_gpio_d15();
//   }
  
// }


uint32_t get_psp_value(void){
  return psp_of_tasks[c_task];
}

void set_psp_value(uint32_t task_psp){
  psp_of_tasks[c_task] = task_psp;
}

void update_next_task(void){
  c_task++;
  c_task %= TASKS;
}

__attribute__((naked)) void switch_sp_to_psp(void)
{
	// Initialize PSP

	__asm volatile ("PUSH {LR}");
	__asm volatile ("BL get_psp_value");
	__asm volatile ("MSR PSP, R0");
	__asm volatile ("POP {LR}");

	// Point SP to PSP
	__asm volatile ("MOV R0, #0x02");
	__asm volatile ("MSR CONTROL, R0");
	__asm volatile ("BX LR");
}

void systick_T_init(uint32_t tick) {
  uint32_t *SYST_RVR = (uint32_t*) 0xE000E014;
  uint32_t *SYST_CSR = (uint32_t*) 0xE000E010;

  uint32_t reload_value = (HSI_CLOCK / tick) -1 ;

    //clear the Reload register 24 bits  and then load the count 
        *SYST_RVR &= ~(0x00FFFFFF);
        *SYST_RVR |= reload_value;


    //configure the Control register , clock source enable systick exception and enable the counter 
        *SYST_CSR |=  7 << 0 ;
    
}

__attribute__((naked)) void sched_stack_init(uint32_t stack_sched) {
  __asm volatile ("MSR MSP,R0");
  __asm volatile ("BX LR");
}

void enable_faults() {
  uint32_t *SHCSR = (uint32_t*)0xE000ED24;

  *SHCSR |= ( 7 << 16 ) ;  //mem , bus , usage faults

}

void init_tasks_stack(void) {
  uint32_t *PSP;


  //Stack frame : xPSR / PC / LR / General purpose registers R12 -> R0 / Scratch registers R11 -> R4
  for (int task=0 ; task < TASKS ; task++) {
    PSP = (uint32_t*)psp_of_tasks[task];

    PSP--;
    *PSP = xPSR; //0x00100000 T (thumb state) bit of PSR register

    PSP--;
    *PSP = task_handlers[task]; //PC next instruction to execute is the task handler

    PSP--;
    *PSP = 0xFFFFFFFD; //LR

    for (int reg = 0 ; reg < 13 ; reg++) {
      PSP--;
      *PSP = 0;
    }

    psp_of_tasks[task] = (uint32_t)PSP;
    
  }
}


/************ HAndlers *************************** */
__attribute__((naked)) void SysTick_Handler(void) {
  //toggle_gpio_d12();
  __asm volatile("PUSH {LR}");
  // __asm volatile("BL toggle_gpio_d12");
  //1. Get current running task's PSP value
  __asm volatile("MRS R0,PSP");
  //2. Using that PSP value store SF2 (R4 to R11)
  __asm volatile("STMDB R0!, {R4-R11}");

  

  //1. save the current value of PSP
  __asm volatile ("BL set_psp_value");


  //1. Decide next task to run
  __asm volatile ("BL update_next_task");

  //2.gets its past PSP value
  __asm volatile ("BL get_psp_value");

  //3. Using that PSP value retrieve SF2(R4 to R11)
  __asm volatile ("LDMIA R0!, {R4-R11}");

  //4. update PSP and exit
  __asm volatile("MSR PSP,R0");

  __asm volatile ("POP {LR}");

  __asm volatile ("BX LR");
}

void HardFault_Handler(void) {
  while(1) {

  }
}

void MemManage_Handler(void) {
  while(1) {
    
  }
}

void BusFault_Handler(void) {
  while(1) {
    
  }
}

void UsageFault_Handler(void) {
  while(1) {
    
  }
}

