/**
 * @file tasks.h
 * @brief Task management functions for the Embedded Scheduler Project.
 *
 * This file defines the TaskControlBlock structure and function prototypes for
 * task management, including task initialization and scheduling.
 *
 * @author Bilel
 * @date 2024-10-28
 */

#include <stdint.h>


/**
 * @brief Initializes the Main Stack Pointer (MSP) for the scheduler.
 *
 * This function sets the Main Stack Pointer (MSP) to the specified stack 
 * address provided as an argument. The function is marked as naked, meaning 
 * it does not have a prologue or epilogue generated by the compiler, allowing 
 * for direct assembly instructions.
 *
 * @param stack_sched The address to set as the Main Stack Pointer (MSP).
 *                    This address should point to the top of the stack space 
 *                    allocated for the scheduler.
 * @return None
 */
__attribute__((naked)) void sched_stack_init(uint32_t);

/**
 * @brief Initializes the task stacks and their respective states.
 *
 * This function initializes the stack pointers for each task and sets 
 * the initial state of the tasks to RUNNING. It also prepares the 
 * stack frames for each task, setting up the necessary registers 
 * for context switching.
 *
 * The function performs the following steps:
 * - Sets each task's state to RUNNING.
 * - Initializes the stack pointer for each task with the address of 
 *   the allocated stack.
 * - Prepares the stack frame by storing:
 *   - xPSR (Program Status Register) to indicate the Thumb state.
 *   - The address of the task handler function (PC).
 *   - The link register (LR) value.
 *   - Initializes general-purpose registers (R0 to R12) to zero.
 * 
 * @param None
 * @return None
 */
void init_tasks_stack(void);

/**
 * @brief Task 1 routine.
 * 
 *
 * @details
 * - This routine simulates task scheduling in a multitasking environment.
 * 
 * @param None
 * @return None
 */
void task1_routine(void);

/**
 * @brief Task 2 routine.
 * 
 *
 * @details
 * - This routine simulates task scheduling in a multitasking environment.
 * 
 * @param None
 * @return None
 */
void task2_routine(void);

/**
 * @brief Task 3 routine.
 * 
 *
 * @details
 * - This routine simulates task scheduling in a multitasking environment.
 * 
 * @param None
 * @return None
 */
void task3_routine(void);

/**
 * @brief Task 4 routine.
 * 
 *
 * @details
 * - This routine simulates task scheduling in a multitasking environment.
 * 
 * @param None
 * @return None
 */
void task4_routine(void);

/**
 * @brief Idle Task routine.
 * 
 *
 * @details
 * - This routine simulates task scheduling in a multitasking environment.
 * 
 * @param None
 * @return None
 */
void idle_routine(void);

/**
 * @brief Delays the execution of the current task for a specified number of ticks.
 * 
 * This function updates the task state of the currently running task (excluding the idle task) 
 * to `BLOCKED` and sets a delay period. The PendSV interrupt is triggered to facilitate task switching.
 *
 * @param delay_tick The number of system ticks to delay the task.
 *
 * @details
 * - If the current task (`c_task`) is not the idle task (task 0), the function sets `remaining_ticks` 
 *   to the current global tick count plus the specified `delay_tick`.
 * - The `task_state` of the current task is updated to `BLOCKED`, indicating it should not run 
 *   until the delay period has expired.
 * - `trig_pendsv()` is called to initiate a context switch, allowing another task to run.
 * 
 * 
 * @note The idle task (task 0) cannot be delayed.
 * 
 * @return None
 */
void task_delay(uint32_t delay_tick);